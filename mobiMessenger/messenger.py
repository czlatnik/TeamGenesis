'''This messenger will function as a the main communication with MoBI.
It will be used to pull data and push data.'''
#!/usr/bin/env python
#imports
#zmq or ZeroMQ is the connection library used to talk to MoBI
import zmq
# sys and time are standard python libraries
#import sys
import time
# This import was generated by our protobuf message library
# and corresponding .proto file in the 'msg' directory
from mobiMessenger import BtPacket_pb2


#create this object in order to pull data
class mobiMessenger(object):

    #this will initialize the messenger
    def __init__(self, host = "192.168.0.101"): #the default is 192.168.0.101; however, it can be changed
        #use self so that you can access host later in the class
        self.host = host
        # topicName is the name of the topic you wish to look at.  It has
        # three parts, the device, the service, and the characteristic.
        # These three parts are divided by slashes like this:
        # device/service/characteristic
        # Change this topicName to whichever topic you wish to see heart
        # rate from.  The heart rate standard is one from the Bluetooth SIG
        # so the service and characteristic should be the same, you'll
        # just need to change the device name to match your device's name
        # in MoBI
        #topicNames = "Polar H7 AEA87610/Heart Rate/Heart Rate Measurement"
        #topicName2 = "Polar H7 919CB51C/Heart Rate/Heart Rate Measurement"

        # These four lines create a zmq context and socket.  A URL is
        # constructed using the host provided above and the default MoBI
        # publisher socket of 5556.  The empty string given in the SUBSCRIBE
        # call means we're not using zmq to filter the packets (we'll do that
        # ourselves as we receive them).
        context = zmq.Context()
        self.subSocket = context.socket(zmq.SUB)
        self.subSocket.connect("tcp://%s:5556" % self.host)
        self.subSocket.setsockopt_string(zmq.SUBSCRIBE, "")

    def pullData(self, topicName = "Polar H7 AEA87610/Heart Rate/Heart Rate Measurement"):
        #this initializes the following variables
        rate = -1
        packetString = None

        for i in range(0,10):
            # This try/except block attempts to read a message from the zmq
            # socket. We don't want to block the loop because we want the user
            # to be able to terminate the program, so we provide the zmq.NOBLOCK
            # argument. Mateo-I'm not sure if the NOBLOCK is still necessary because I changed the code
            try:
                packetString = self.subSocket.recv(zmq.NOBLOCK)
                loop = False
            except zmq.ZMQError:
                # If we don't get a packet, this exception is thrown, so we wait
                # 100 milliseconds (0.1 seconds) and try again.  If we didn't wait
                # at all, the loop would run way too fast and consume a lot of CPU time.
                time.sleep(0.1)

        if packetString is None:
            raise "No Packet Found Error"

        # If we get here, we actually got data from the socket!
        # We'll create a packet using the string data we received from the zmq
        # socket.
        btPacket = BtPacket_pb2.BtPacket()
        btPacket.ParseFromString(packetString)

        # Here we check that the packet we got is the topic we're looking for which
        # was specified above.  If it is, we'll parse the data further.  If not,
        # the script continues to the next iteration of the while loop.
        if btPacket.topicName == topicName:
            # Grab the data into a variable so we can parse it
            data = btPacket.data
            # Python lets us extract subsets of the data.  In this case, the heart rate
            # specification from the Bluetooth SIG tells us that the actual heart rate
            # starts at byte 3 (indexed from zero, which is why we use 2), and is 4 bytes
            # long, this gives us the data[2:4] call.  The int function call type casts
            # that data as an integer, and the 16 tells the int function call that the
            # number is in base 16 (or hexidecimal)
            rate = int(data[2:4], 16)


        return [topicName, rate]